package main

import "fmt"

/*
面向对象概述
• 在没有面向对象的年代，编程的方式是面向过程的
• 面向过程的编程，管理的是一个一个的函数，撸工程就是堆砌大量的函数
• 面向对象中类的概念，Go语言是通过结构体来实现的
• 类/结构体是对函数的进一步封装，即把有机关联的变量和函数封装为一个结构体
• 有了类/结构体的概念以后，撸工程就由管理大量的函数变为了管理少量的类
• 书本理论中面向函数的三大特性是：封装、继承、多态（有时会再加一个抽象）
• 继承性实现了低成本地扩展原有代码
• 多态性实现了大规模代码的组装和调度
• 面向对象使工程开发变成了搭建框架和组装模块的游戏
• 面向对象的出现使大规模协作与大规模开发变得更容易了
 */

//封装性概述
//
//封装就是将业务逻辑相近的变量和函数封装在一起，成为一个结构体
//被封起来的变量称之为属性
//被封起来的函数称之为方法
//封装的意义，在于整理和简化代码结构
//封装也是继承和多态的基础
/*
1. 封装结构体
//下面的例子，把狗的属性（名字和性别）和狗的方法（取名字和咬人）封装成了一个结构体
//定义结构体

 */
type Dog struct {
	//定义狗的属性
	name string
	sex int
}

/*封装狗的方法*/
//setter
func (d *Dog)SetName(name string)  {
	//在这里可以加一些权限校验
	d.name = name
}

//getter
func (d *Dog)GetName() string {
	//在这里可以加一些权限校验
	return d.name
}

//定义咬人方法
func (d *Dog)bite()  {
	fmt.Printf("让本汪%s来给你一些震撼教育...",d.name)
}

func  demo23()  {
	d := Dog{"毛毛",1}
	//d.name = "d2222ds"
	//d.sex = 1
	fmt.Printf("d的类型%T，value：%#v", d, d)

}

func demo24() {
	dp := new(Dog)

	//通过【指针】访问结构体的【成员】（包括属性和方法）和通过【值】访问一模一样
	dp.SetName("臭皮")
	dp.bite()
}

/*
2.使用工厂模式创建对象

* 封装【创建实例的重复复杂过程】为固定的套路和【模式】
* 以后就可以【反反复复】、【轻松加愉快】地复用模式和套路了
* 正所谓【自古真情没卵用，唯有套路得人心】，阿门
* 这个一次封装、反复玩弄的套路，就称为【工厂模式】
* 工厂模式——将造实例这件事情做专业化的封装，并反复调用

 */
//工厂方法
func NewDog(name string,sex int) *Dog  {
	d := new(Dog)
	d.name = name
	d.sex = sex
	return d
}

//使用工厂模式创建对象
func demo25() {
	xiaohei := NewDog("小黑", 1)
	xiaohei.bite()
}


func main()  {
	demo25()
}