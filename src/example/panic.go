package main

import "fmt"

/*

恐慌概述

代码在运行时如果出现异常，系统会报出恐慌（panic）并终止运行
IDE和终端打印的恐慌日志，包含了恐慌的信息以及报恐慌所在的代码行
恐慌好比一种震撼的暴力教育，其目的在于警示开发者，什么是可以的而什么又是不可以的
代码在交付使用前要经过充分测试，处理一切可能的恐慌

 */

//系统报恐慌
//本例中由于我们错误地使用了一个超出数组长度的下标，导致系统报出恐慌

func demo22() {
	a := [5]int{0, 1, 2, 3, 4}

	a[1] = 123
	index := 2 + 8

	//系统报恐慌：运行时错误（exe在执行的过程中发生的错误），下标越界
	//panic: runtime error: index out of range
	a[index] = 123
}

/*
自己报恐慌
*除了系统报出恐慌以外，我们还可以通过内建函数panic自己报出恐慌
*自己报恐慌的目的，是预测程序在运行时可能出现的异常情形，并提示当前代码的调用者以错误信息
*下面的例子中，计算圆面积这一函数在调用时如果传入了一个负数的半径，则会报出恐慌，提示半径是不可以为负数的，这样做相当于强制代码的调用者传入非负的半径
*/

func getCircleArea(radius float32) (area float32) {
	//如果半径参数为负数，则抛出异常
	if radius < 0{
		panic("颤抖吧，您的智商已下线，半径不能为负数")
	}
	return 3.14 * radius * radius
}
func demo022() {
	//程序会因为抛出的异常未经处理而崩溃
	getCircleArea(-5)
}

/*
处理恐慌
程序在上线前必须测试和扫灭所有可能的恐慌
在没有对恐慌进行任何处理前，程序会在报恐慌的行崩溃
Go语言提供了recover內建函数，让崩溃的程序复活并返回造成程序崩溃的error实例
所以我们可以在正式的业务逻辑开始前，事先挂起一个延时处理恐慌的函数，在其中借助recover函数获得造成程序崩溃的error并处理
当程序在123行崩溃时，123行以后的代码就不会再执行了，而是直接跳转到defer了的恐慌处理程序

*/

func demo023() {

	//延时执行恐慌处理程序
	//延时到什么时候？①函数正常结束前②恐慌发生时（函数内恐慌以后的代码将不会执行）
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
		}
	}()

	//下面的函数会恐慌(报恐慌)
	getCircleArea(-5)

	//所以这里执行不到，而是直接跳到defer所定义的恐慌处理程序
	print("这里有美女相赠")
}

//下面这段代码对前面的demo23进行了调用
//由于demo23()是一个已经定义了恐慌处理方式的函数，程序不会因为demo23中的恐慌而崩溃

func main() {
	//本来该应该因恐慌而死，但已经在其中插入了异常(恐慌)处理程序，就不会造成程序崩溃
	//丢失的部分仅仅为demo23中恐慌以后的部分
	demo023()

	fmt.Println("抢钱抢粮抢地盘")
	fmt.Println("GAME OVER")
}

//out
//颤抖吧，您的智商已下线，半径不能为负数
//抢钱抢粮抢地盘
//GAME OVER
