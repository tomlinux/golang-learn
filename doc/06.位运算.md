# 位运算
*  按位与：两位都为1，结果就为1
*  按位或：只要有一个1，结果就是1
*  按位异或：两位不同则为1，相同则为0
```
func bitOperation() {
fmt.Println(22 & 13)
fmt.Println(22 | 13)
fmt.Println(22 ^ 13)
}
```

*  移位运算
左移：末尾添0
右移：移出边界
```
func shiftOperation() {
//22类型为int，在64位机下实际为int64,

    //10110右移3位变成10,即结果为2
    fmt.Println(22 >> 3)
    //10110左移3位变成10110000,即结果为176
    fmt.Println(22 << 3)
}
```

*  负数的表示
```
使用补码：即（原码）取反加一
以22为例：
原码0001,0110，
取反1110,1001，
加一1110,1010，
即-22就是1110,1010
```
移位运算形成负数
整型值没有明确声明类型时，默认使用int，在64位机下实际为int64
int8的22，二进制为10110,左移3位10110000，实际上成为负数-80

```
func shiftNegative() () {
fmt.Printf("type=%T\n",22)

    //原码：0001,0110
    //左三：1011，0000，这是一个负数的补码，需要通过减一取反得到绝对值
    //减一：1010,1111
    //取反：0101,0000，为80
    //所以左三后实际表示-80
    var a int8 = 22
    fmt.Println(a<<3)
}
```

移位运算的溢出
左移达到类型允许的最高位，就会overflow溢出，形成事实上的工程错误
int8的22，二进制为10110,左移4位1,01100000，高位溢出形成
移除后有效位的值为96，而它没有任何实际意义
```
func shiftOverflow() () {
var a int8 = 22

    //左移4位后：1,0110,0000
    //忽略溢出后：0110,0000，即96
    //而事实上这已经是一个工程错误了
    fmt.Println(a<<4)
}
```